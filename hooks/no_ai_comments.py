#!/usr/bin/env python3
"""Hook to prevent tool attribution comments in code.

Blocks comments like "Generated by ...", "written by ...", etc.
Excludes markdown files (documentation can mention tools by name).
"""

import json
import re
import sys

# File extensions to skip (documentation files)
EXCLUDED_EXTENSIONS = {".md", ".mdx", ".rst", ".txt"}

# Patterns for tool attribution comments - require attribution context
ATTRIBUTION_PATTERNS = [
    r"generated by (claude|ai|copilot|gpt|chatgpt|anthropic)",
    r"written by (claude|ai|copilot|gpt|chatgpt)",
    r"created by (claude|ai|copilot|gpt|chatgpt)",
    r"ai[- ]generated",
    # Comment patterns with attribution context (not just mentioning the name)
    r"#\s*claude\s+(generated|wrote|created|made)",
    r"//\s*claude\s+(generated|wrote|created|made)",
    r"/\*\s*claude\s+(generated|wrote|created|made)",
]

COMBINED_PATTERN = re.compile("|".join(ATTRIBUTION_PATTERNS), re.IGNORECASE)


def is_excluded_file(file_path: str) -> bool:
    """Check if file should be excluded from attribution checks."""
    if not file_path:
        return False
    lower_path = file_path.lower()
    return any(lower_path.endswith(ext) for ext in EXCLUDED_EXTENSIONS)


def main():
    try:
        data = json.load(sys.stdin)
        tool_input = data.get("tool_input", {})
        file_path = tool_input.get("file_path", "")

        # Skip documentation files
        if is_excluded_file(file_path):
            sys.exit(0)

        # Check new_string (Edit tool)
        new_string = tool_input.get("new_string", "")
        if new_string and COMBINED_PATTERN.search(new_string):
            print("Blocked: Tool attribution comments not allowed in code.")
            sys.exit(2)

        # Check content (Write tool)
        content = tool_input.get("content", "")
        if content and COMBINED_PATTERN.search(content):
            print("Blocked: Tool attribution comments not allowed in code.")
            sys.exit(2)

        sys.exit(0)
    except Exception:
        sys.exit(0)


if __name__ == "__main__":
    main()
